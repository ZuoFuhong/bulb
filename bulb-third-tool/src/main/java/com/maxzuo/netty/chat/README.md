## Netty私有协议栈

广义上区分，通行协议可以分为公有协议和私有协议，由于私有协议的灵活性，他往往会在某个公司或者组织内部使用，按需定制。

私有协议本质上是厂商内部发展和采用的标准，除非授权，其他厂商一般无权使用该协议，私有协议也成为非标准协议，就是未经国际或者国家
标准化组织采纳或批准，由某个企业自己定制，协议实现细节不愿公开，只有企业自己生产的设备之间使用的协议。私有协议具有封闭性、垄断
性、排他性等特点。

> Netty协议栈功能

1）基于Netty的NIO通信框架，提供高性能的异步通行能力；

2）提供消息的编解码框架，可以进行POJO的序列化和反序列化；

3）提供基于IP地址的白名单接入认证机制；

4）链路的有效性校验机制；

5）链路的断链重连机制。

> Netty协议栈通信模型

1）Netty协议栈客户端发送握手请求消息，携带节点ID等有效身份认证信息；

2）Netty协议栈服务端对握手请求消息进行合法性校验，包括节点ID有效性校验、节点重复登录校验和IP地址合法性校验，校验通过后，返回
登录成功的握手应答消息；

3）链路建立成功之后，客户端发送业务消息；

4）链路成功之后，服务端发送心跳消息；

5）链路建立成功之后，客户端发送心跳消息；

6）链路建立成功之后，服务端发送业务消息；

7）服务端退出时，服务端关闭连接，客户端感知对方关闭连接后，被动关闭客户端连接。

备注：Netty 协议通行双方链路建立成功之后，双方可以进行全双工通信，无论客户端还是服务端，都可以主动发送请求消息给对方，通行方式
可以是TWO WAY（双向）或者ONE WAY（单向）。双方之间的心跳采用Ping-Pong机制，当链路出入空闲状态时，客户端主动发送Ping消息给服
务端，服务端接收到Ping消息后发送应答消息Pong给客户端，如果客户端连续发送N条Ping消息都没有接收到服务端返回的Pong消息，说明链路
已经挂死或者对方处于异常状态，客户端主动关闭连接，间隔周期T后发起重新操作，直到重连成功。

> 消息定义

Netty协议栈消息定义包含两部分：消息头和消息体。其中消息体是一个Object类型，消息头则如下所示：

- **crcCode**：整型int，Netty消息的校验码，它由三部分组成：

1）0xABEF：固定值，表明该消息是Netty协议消息，2个字节。

2）主版本号：1~255，1个字节；

3）次版本号：1~255，1个字节；

ercCode = 0xABEF + 主版本号 + 次版本号

- **length**：整型int，消息长度，整个消息，包括消息头和消息体

- **sessionID**：长整形long，集群节点内全局唯一，由会话ID生成器生成

- **type**：Byte类型

0：业务请求消息

1：业务响应消息

2：业务ONE WAY消息（即是请求又是响应消息）

3：握手请求消息

4：握手应答消息

5：心跳请求消息

6：心跳应答消息

- **priority**：Byte类型，消息优先级：0~255

- **attachment**：Map<String, Object>变长，可选字段，用于扩展消息头

> Netty协议的编解码规范

- **Netty消息编码规范**

(1) crcCode: java.nio.ByteBuffer.putInt(int value)，如果采用其它缓存区实现，必须与其等价

(2) length: java.nio.ByteBuffer.putInt(int value)，如果采用其它缓冲区实现，必须与其等价

(3) sessionID: java.nio.ByteBuffer.putLong(long value)，如果采用其它缓冲区实现，必须与其等价

(4) type: java.nio.ByteBuffer.put(byte b)，如果采用其它缓冲区实现，必须与其等价

(5) priority: java.nio.ByteBuffer.put(byte b)，如果采用其它缓冲区实现，必须与其等价

(6) attachment: 如果长度为0，表示没有可选附件，则将长度编码为0，即java.nio.ByteBuffer.putInt(0)，如果大于0，表示有附件
需要编码具体规则如下：

- 首先对附件的个数进行编码，java.nio.ByteBuffer.putInt(attachment.size());

- 然后对Key进行编码，先编码长度，然后再将它转换成byte数组之后编码内容，具体代码如下：

```
String key = null;
byte[] value = null;
for (Map.Entry<String, Object> param: attachment:entrySet()) {
    key = param.getKey();
    buffer.writeString(key);
    value = marshaller.writeObject(param.getValue());
    buffer.writeBinary(value);
}
key = null;
value = null;
```

(7) body的编码: 通过JBoss Marshalling将其序列化为byte数组，然后调用java.nio.ByteBuffer.put(byte[] src);将其写入
ByteBuffer缓冲区中。在所有的内容都编码完成之后更新消息头的length字段。

- **Netty消息解码规范**

(1) crcCode: java.nio.ByteBuffer.getInt()获取校验码字段，如果采用其它缓存区实现，必须与其等价

(2) length: java.nio.ByteBuffer.getInt()获取Netty消息的长度，如果采用其它缓冲区实现，必须与其等价

(3) sessionID: java.nio.ByteBuffer.getLong()获取会话ID，如果采用其它缓冲区实现，必须与其等价

(4) type: java.nio.ByteBuffer.get()获取消息类型，如果采用其它缓冲区实现，必须与其等价

(5) priority: java.nio.ByteBuffer.get()获取消息优先级，如果采用其它缓冲区实现，必须与其等价

(6) attachment: 它的解码规则为-首先创建一个新的attachment对象，调用java.nio.ByteBuffer.getInt()获取附件的长度，
如果为0，说明附件为空，解码结束，解析解消息体，否则，根据长度通过for循环进行解码。

```
String key = null;
object value = null;
for (int i = 0; i < size; i++) {
    key = buffer.readString();
    value = unmarshaller.readObject(buffer.readBinary());
    this.attachment.put(key, value);
}
key = null;
value = null;
```

(7) body: 使用JBoss marshaller对其进行解码

> 链路的建立

不区分客户端和服务端：如果A节点需要B节点的服务，但是A和B之间还没有建立物理链路，则由调用方主动发起连接，此时调用方为客户端，
被调用方为服务端。使用简单的黑白名单进行认证，实际环境中，应该使用密钥，用户名密码等方式。

客户端与服务端链路建立成功后，由客户端发送握手请求消息，握手请求消息的定义如下：

1）消息头的type字段为3；

2）可选附件个数为0；

3）消息体为空；

4）握手消息的长度为22个字节；

服务端接收到握手请求消息，如果IP校验通过，返回握手成功应答给客户端，应用层链路建立成功。握手应答消息定义如下：

1）消息头type为4

2）可选附件个数为0

3）消息体为byte类型的结果，"0"表示认证成功，"-1"表示认证失败。

链路成功建立后，客户端和服务端就可以相互发送业务消息了。

> 链路的关闭

由于采用长连接通信，正常的业务运行期间，双方通过心跳和业务消息维持链路，任何一方都不需要主动关闭连接。

但是，在以下情况下，客户端和服务端需要关闭连接。

(1) 当对方宕机或者重启时，会主动释放链路，另一方读取到操作系统的通知信号，得到对方REST链路，需要关闭连接，释放自身的句柄等
资源。由于采用TCP全双工通信，通信双方都需要关闭连接，释放资源;

(2) 消息在读写过程中，发生了I/O异常，需要主动关闭连接;

(3) 心跳消息读写过程中发生了I/O异常，需要主动关闭连接;

(4) 心跳超时，需要主动关闭连接；

(5) 发生编码异常等不可恢复的错误时，需要主动关闭连接；

> 可靠性设计

网络环境是恶劣的。意外无法避免，需要在出现意外的时候正常工作或者说是恢复，需要可靠性设计的保证。

- **心跳机制**

在凌晨等业务低谷期，如果发生网络闪断、连接被Hang住等网络问题，由于没有业务消息，应用进程很难发现。到了白天业务高峰期，会发生
大量的网络通信失败，严重的会导致一段时间进程内无法处理业务消息。为了解决这个问题，在网络空闲的时候采用心跳机制来检测链路的互
通性，一旦发现了网络故障，立即关闭链路，主动重连。

设计思路：

1）当网络处于空闲时间达到了T(连续周期T没有读写消息)时，客户端主动发送Ping心跳消息给服务端；

2）如果在下一个周期T到来时客户端没有收到对方发送的Pong心跳应答消息或者读取到服务端发送的其他业务消息，则心跳失败计数器+1。

3）每当客户端接收到服务的业务消息或者Pong应答消息时，将心跳失败计数器清0；连续N次没有接收到服务端的Pong消息或者业务消息，则
关闭链路，间隔INTERVAL时间后发起重连操作；

4）服务端网络空闲状态持续时间达到T后，服务器端将心跳失败计数器+1；只要接收到客户端发送的Ping消息或者其他业务消息，计数器清0。

5）服务器端连续N次没有接收到客户端的Ping消息或者其他业务消息，则关闭链路，释放资源，等待客户端重连。

通过Ping-Pong双向心跳机制，可以保证无论通信哪一方出现网络故障，都能被及时地检测出来。为了防止由于对方短时间内繁忙没有及时返回
应答造成的误判，只有连续N次心跳检测都失败才认定链路已经损害，需要关闭链路并重建链路。

- **重连机制**

如果链路中断，等待INTERVAL时间后，由客户端发起重连操作，如果重连失败，间隔周期INTERVAL后再次发起重连，直到重连成功。

为了保证服务端能够有充足的时间释放句柄资源，在首次断连时客户端等待INTERVAL时间之后在发起重连，而不是失败后就立即重连。

为了保证句柄资源能够及时释放，无论什么场景下的重连失败，客户端都必须保证自身资源被及时释放。

重连失败后，需要打印异常堆栈信息，方便后续的问题定位。

- **重复登录保护**

客户端握手成功之后，链路处于正常状态下，不允许客户端重复登录，以防止客户端在异常状态下反复重连导致句柄资源被耗尽。

服务端接收到客户端的握手请求消息后，首先进行IP地址进行合法性校验，如果校验成功，则在缓存的地址表中查看客户端是否已经登录，如果
已经登录，则拒绝重复登录，返回错误码-1，同时关闭TCP链路，并且在服务端的日志中打印握手失败的原因。

客户端接收到握手失败的应答消息之后，关闭客户端的TCP连接，等待INTERVAL时间之后，再次发起TCP连接，直到认证成功。

为了防止由服务端和客户端对链路状态理解不一致导致的客户端无法握手成功的问题，当服务端连续N次心跳超时之后需要主动关闭链路，同时
清空该客户端的地址缓存信息，以保证后续该客户端可以重连成功，防止被重复登录保护机制拒绝掉。

- **消息缓存重发**

无论是客户端还是服务端，在发生链路中断之后，恢复链路之前，缓存在消息队列的待发送的消息不能丢失。等链路恢复之后，重新发送这些
消息，保证链路中断期间消息不丢失。

同时考虑到内存溢出风险，应该在消息缓存队列中设置上限，当到达上限之后，应该拒绝继续向该队列添加新的消息。

- **可扩展性设计**

Netty协议栈需要具备一定的扩展能力，例如统一的消息拦截、接口日志、安全、加密解密等可以被方便地添加和删除。类似于Servlet的
FilterChain和AOP机制，考虑到性能因素，不推荐通过AOP来实现功能的扩展。